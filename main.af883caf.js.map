{"version":3,"file":"main.af883caf.js","sources":["./environment-dep-replace.cjs??ruleSet[1].rules[2].use[0]!./node_modules/@mui/material/ButtonBase/TouchRipple.js","./environment-dep-replace.cjs??ruleSet[1].rules[2].use[0]!./node_modules/@mui/material/LinearProgress/LinearProgress.js","./environment-dep-replace.cjs??ruleSet[1].rules[2].use[0]!./src/components/Pages/Settings.tsx","./environment-dep-replace.cjs??ruleSet[1].rules[2].use[0]!./src/slices/phraseSlice.ts"],"sourcesContent":["'use client';\n\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nconst _excluded = [\"center\", \"classes\", \"className\"];\nlet _ = t => t,\n  _t,\n  _t2,\n  _t3,\n  _t4;\nimport * as React from 'react';\nimport PropTypes from 'prop-types';\nimport { TransitionGroup } from 'react-transition-group';\nimport clsx from 'clsx';\nimport { keyframes } from '@mui/system';\nimport styled from '../styles/styled';\nimport useThemeProps from '../styles/useThemeProps';\nimport Ripple from './Ripple';\nimport touchRippleClasses from './touchRippleClasses';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst DURATION = 550;\nexport const DELAY_RIPPLE = 80;\nconst enterKeyframe = keyframes(_t || (_t = _`\n  0% {\n    transform: scale(0);\n    opacity: 0.1;\n  }\n\n  100% {\n    transform: scale(1);\n    opacity: 0.3;\n  }\n`));\nconst exitKeyframe = keyframes(_t2 || (_t2 = _`\n  0% {\n    opacity: 1;\n  }\n\n  100% {\n    opacity: 0;\n  }\n`));\nconst pulsateKeyframe = keyframes(_t3 || (_t3 = _`\n  0% {\n    transform: scale(1);\n  }\n\n  50% {\n    transform: scale(0.92);\n  }\n\n  100% {\n    transform: scale(1);\n  }\n`));\nexport const TouchRippleRoot = styled('span', {\n  name: 'MuiTouchRipple',\n  slot: 'Root'\n})({\n  overflow: 'hidden',\n  pointerEvents: 'none',\n  position: 'absolute',\n  zIndex: 0,\n  top: 0,\n  right: 0,\n  bottom: 0,\n  left: 0,\n  borderRadius: 'inherit'\n});\n\n// This `styled()` function invokes keyframes. `styled-components` only supports keyframes\n// in string templates. Do not convert these styles in JS object as it will break.\nexport const TouchRippleRipple = styled(Ripple, {\n  name: 'MuiTouchRipple',\n  slot: 'Ripple'\n})(_t4 || (_t4 = _`\n  opacity: 0;\n  position: absolute;\n\n  &.${0} {\n    opacity: 0.3;\n    transform: scale(1);\n    animation-name: ${0};\n    animation-duration: ${0}ms;\n    animation-timing-function: ${0};\n  }\n\n  &.${0} {\n    animation-duration: ${0}ms;\n  }\n\n  & .${0} {\n    opacity: 1;\n    display: block;\n    width: 100%;\n    height: 100%;\n    border-radius: 50%;\n    background-color: currentColor;\n  }\n\n  & .${0} {\n    opacity: 0;\n    animation-name: ${0};\n    animation-duration: ${0}ms;\n    animation-timing-function: ${0};\n  }\n\n  & .${0} {\n    position: absolute;\n    /* @noflip */\n    left: 0px;\n    top: 0;\n    animation-name: ${0};\n    animation-duration: 2500ms;\n    animation-timing-function: ${0};\n    animation-iteration-count: infinite;\n    animation-delay: 200ms;\n  }\n`), touchRippleClasses.rippleVisible, enterKeyframe, DURATION, ({\n  theme\n}) => theme.transitions.easing.easeInOut, touchRippleClasses.ripplePulsate, ({\n  theme\n}) => theme.transitions.duration.shorter, touchRippleClasses.child, touchRippleClasses.childLeaving, exitKeyframe, DURATION, ({\n  theme\n}) => theme.transitions.easing.easeInOut, touchRippleClasses.childPulsate, pulsateKeyframe, ({\n  theme\n}) => theme.transitions.easing.easeInOut);\n\n/**\n * @ignore - internal component.\n *\n * TODO v5: Make private\n */\nconst TouchRipple = /*#__PURE__*/React.forwardRef(function TouchRipple(inProps, ref) {\n  const props = useThemeProps({\n    props: inProps,\n    name: 'MuiTouchRipple'\n  });\n  const {\n      center: centerProp = false,\n      classes = {},\n      className\n    } = props,\n    other = _objectWithoutPropertiesLoose(props, _excluded);\n  const [ripples, setRipples] = React.useState([]);\n  const nextKey = React.useRef(0);\n  const rippleCallback = React.useRef(null);\n  React.useEffect(() => {\n    if (rippleCallback.current) {\n      rippleCallback.current();\n      rippleCallback.current = null;\n    }\n  }, [ripples]);\n\n  // Used to filter out mouse emulated events on mobile.\n  const ignoringMouseDown = React.useRef(false);\n  // We use a timer in order to only show the ripples for touch \"click\" like events.\n  // We don't want to display the ripple for touch scroll events.\n  const startTimer = React.useRef(0);\n\n  // This is the hook called once the previous timeout is ready.\n  const startTimerCommit = React.useRef(null);\n  const container = React.useRef(null);\n  React.useEffect(() => {\n    return () => {\n      if (startTimer.current) {\n        clearTimeout(startTimer.current);\n      }\n    };\n  }, []);\n  const startCommit = React.useCallback(params => {\n    const {\n      pulsate,\n      rippleX,\n      rippleY,\n      rippleSize,\n      cb\n    } = params;\n    setRipples(oldRipples => [...oldRipples, /*#__PURE__*/_jsx(TouchRippleRipple, {\n      classes: {\n        ripple: clsx(classes.ripple, touchRippleClasses.ripple),\n        rippleVisible: clsx(classes.rippleVisible, touchRippleClasses.rippleVisible),\n        ripplePulsate: clsx(classes.ripplePulsate, touchRippleClasses.ripplePulsate),\n        child: clsx(classes.child, touchRippleClasses.child),\n        childLeaving: clsx(classes.childLeaving, touchRippleClasses.childLeaving),\n        childPulsate: clsx(classes.childPulsate, touchRippleClasses.childPulsate)\n      },\n      timeout: DURATION,\n      pulsate: pulsate,\n      rippleX: rippleX,\n      rippleY: rippleY,\n      rippleSize: rippleSize\n    }, nextKey.current)]);\n    nextKey.current += 1;\n    rippleCallback.current = cb;\n  }, [classes]);\n  const start = React.useCallback((event = {}, options = {}, cb = () => {}) => {\n    const {\n      pulsate = false,\n      center = centerProp || options.pulsate,\n      fakeElement = false // For test purposes\n    } = options;\n    if ((event == null ? void 0 : event.type) === 'mousedown' && ignoringMouseDown.current) {\n      ignoringMouseDown.current = false;\n      return;\n    }\n    if ((event == null ? void 0 : event.type) === 'touchstart') {\n      ignoringMouseDown.current = true;\n    }\n    const element = fakeElement ? null : container.current;\n    const rect = element ? element.getBoundingClientRect() : {\n      width: 0,\n      height: 0,\n      left: 0,\n      top: 0\n    };\n\n    // Get the size of the ripple\n    let rippleX;\n    let rippleY;\n    let rippleSize;\n    if (center || event === undefined || event.clientX === 0 && event.clientY === 0 || !event.clientX && !event.touches) {\n      rippleX = Math.round(rect.width / 2);\n      rippleY = Math.round(rect.height / 2);\n    } else {\n      const {\n        clientX,\n        clientY\n      } = event.touches && event.touches.length > 0 ? event.touches[0] : event;\n      rippleX = Math.round(clientX - rect.left);\n      rippleY = Math.round(clientY - rect.top);\n    }\n    if (center) {\n      rippleSize = Math.sqrt((2 * rect.width ** 2 + rect.height ** 2) / 3);\n\n      // For some reason the animation is broken on Mobile Chrome if the size is even.\n      if (rippleSize % 2 === 0) {\n        rippleSize += 1;\n      }\n    } else {\n      const sizeX = Math.max(Math.abs((element ? element.clientWidth : 0) - rippleX), rippleX) * 2 + 2;\n      const sizeY = Math.max(Math.abs((element ? element.clientHeight : 0) - rippleY), rippleY) * 2 + 2;\n      rippleSize = Math.sqrt(sizeX ** 2 + sizeY ** 2);\n    }\n\n    // Touche devices\n    if (event != null && event.touches) {\n      // check that this isn't another touchstart due to multitouch\n      // otherwise we will only clear a single timer when unmounting while two\n      // are running\n      if (startTimerCommit.current === null) {\n        // Prepare the ripple effect.\n        startTimerCommit.current = () => {\n          startCommit({\n            pulsate,\n            rippleX,\n            rippleY,\n            rippleSize,\n            cb\n          });\n        };\n        // Delay the execution of the ripple effect.\n        startTimer.current = setTimeout(() => {\n          if (startTimerCommit.current) {\n            startTimerCommit.current();\n            startTimerCommit.current = null;\n          }\n        }, DELAY_RIPPLE); // We have to make a tradeoff with this value.\n      }\n    } else {\n      startCommit({\n        pulsate,\n        rippleX,\n        rippleY,\n        rippleSize,\n        cb\n      });\n    }\n  }, [centerProp, startCommit]);\n  const pulsate = React.useCallback(() => {\n    start({}, {\n      pulsate: true\n    });\n  }, [start]);\n  const stop = React.useCallback((event, cb) => {\n    clearTimeout(startTimer.current);\n\n    // The touch interaction occurs too quickly.\n    // We still want to show ripple effect.\n    if ((event == null ? void 0 : event.type) === 'touchend' && startTimerCommit.current) {\n      startTimerCommit.current();\n      startTimerCommit.current = null;\n      startTimer.current = setTimeout(() => {\n        stop(event, cb);\n      });\n      return;\n    }\n    startTimerCommit.current = null;\n    setRipples(oldRipples => {\n      if (oldRipples.length > 0) {\n        return oldRipples.slice(1);\n      }\n      return oldRipples;\n    });\n    rippleCallback.current = cb;\n  }, []);\n  React.useImperativeHandle(ref, () => ({\n    pulsate,\n    start,\n    stop\n  }), [pulsate, start, stop]);\n  return /*#__PURE__*/_jsx(TouchRippleRoot, _extends({\n    className: clsx(touchRippleClasses.root, classes.root, className),\n    ref: container\n  }, other, {\n    children: /*#__PURE__*/_jsx(TransitionGroup, {\n      component: null,\n      exit: true,\n      children: ripples\n    })\n  }));\n});\nprocess.env.NODE_ENV !== \"production\" ? TouchRipple.propTypes = {\n  /**\n   * If `true`, the ripple starts at the center of the component\n   * rather than at the point of interaction.\n   */\n  center: PropTypes.bool,\n  /**\n   * Override or extend the styles applied to the component.\n   * See [CSS API](#css) below for more details.\n   */\n  classes: PropTypes.object,\n  /**\n   * @ignore\n   */\n  className: PropTypes.string\n} : void 0;\nexport default TouchRipple;","'use client';\n\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nconst _excluded = [\"className\", \"color\", \"value\", \"valueBuffer\", \"variant\"];\nlet _ = t => t,\n  _t,\n  _t2,\n  _t3,\n  _t4,\n  _t5,\n  _t6;\nimport * as React from 'react';\nimport PropTypes from 'prop-types';\nimport clsx from 'clsx';\nimport { unstable_composeClasses as composeClasses } from '@mui/base/composeClasses';\nimport { keyframes, css, darken, lighten } from '@mui/system';\nimport capitalize from '../utils/capitalize';\nimport useTheme from '../styles/useTheme';\nimport styled from '../styles/styled';\nimport useThemeProps from '../styles/useThemeProps';\nimport { getLinearProgressUtilityClass } from './linearProgressClasses';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { jsxs as _jsxs } from \"react/jsx-runtime\";\nconst TRANSITION_DURATION = 4; // seconds\nconst indeterminate1Keyframe = keyframes(_t || (_t = _`\n  0% {\n    left: -35%;\n    right: 100%;\n  }\n\n  60% {\n    left: 100%;\n    right: -90%;\n  }\n\n  100% {\n    left: 100%;\n    right: -90%;\n  }\n`));\nconst indeterminate2Keyframe = keyframes(_t2 || (_t2 = _`\n  0% {\n    left: -200%;\n    right: 100%;\n  }\n\n  60% {\n    left: 107%;\n    right: -8%;\n  }\n\n  100% {\n    left: 107%;\n    right: -8%;\n  }\n`));\nconst bufferKeyframe = keyframes(_t3 || (_t3 = _`\n  0% {\n    opacity: 1;\n    background-position: 0 -23px;\n  }\n\n  60% {\n    opacity: 0;\n    background-position: 0 -23px;\n  }\n\n  100% {\n    opacity: 1;\n    background-position: -200px -23px;\n  }\n`));\nconst useUtilityClasses = ownerState => {\n  const {\n    classes,\n    variant,\n    color\n  } = ownerState;\n  const slots = {\n    root: ['root', `color${capitalize(color)}`, variant],\n    dashed: ['dashed', `dashedColor${capitalize(color)}`],\n    bar1: ['bar', `barColor${capitalize(color)}`, (variant === 'indeterminate' || variant === 'query') && 'bar1Indeterminate', variant === 'determinate' && 'bar1Determinate', variant === 'buffer' && 'bar1Buffer'],\n    bar2: ['bar', variant !== 'buffer' && `barColor${capitalize(color)}`, variant === 'buffer' && `color${capitalize(color)}`, (variant === 'indeterminate' || variant === 'query') && 'bar2Indeterminate', variant === 'buffer' && 'bar2Buffer']\n  };\n  return composeClasses(slots, getLinearProgressUtilityClass, classes);\n};\nconst getColorShade = (theme, color) => {\n  if (color === 'inherit') {\n    return 'currentColor';\n  }\n  if (theme.vars) {\n    return theme.vars.palette.LinearProgress[`${color}Bg`];\n  }\n  return theme.palette.mode === 'light' ? lighten(theme.palette[color].main, 0.62) : darken(theme.palette[color].main, 0.5);\n};\nconst LinearProgressRoot = styled('span', {\n  name: 'MuiLinearProgress',\n  slot: 'Root',\n  overridesResolver: (props, styles) => {\n    const {\n      ownerState\n    } = props;\n    return [styles.root, styles[`color${capitalize(ownerState.color)}`], styles[ownerState.variant]];\n  }\n})(({\n  ownerState,\n  theme\n}) => _extends({\n  position: 'relative',\n  overflow: 'hidden',\n  display: 'block',\n  height: 4,\n  zIndex: 0,\n  // Fix Safari's bug during composition of different paint.\n  '@media print': {\n    colorAdjust: 'exact'\n  },\n  backgroundColor: getColorShade(theme, ownerState.color)\n}, ownerState.color === 'inherit' && ownerState.variant !== 'buffer' && {\n  backgroundColor: 'none',\n  '&::before': {\n    content: '\"\"',\n    position: 'absolute',\n    left: 0,\n    top: 0,\n    right: 0,\n    bottom: 0,\n    backgroundColor: 'currentColor',\n    opacity: 0.3\n  }\n}, ownerState.variant === 'buffer' && {\n  backgroundColor: 'transparent'\n}, ownerState.variant === 'query' && {\n  transform: 'rotate(180deg)'\n}));\nconst LinearProgressDashed = styled('span', {\n  name: 'MuiLinearProgress',\n  slot: 'Dashed',\n  overridesResolver: (props, styles) => {\n    const {\n      ownerState\n    } = props;\n    return [styles.dashed, styles[`dashedColor${capitalize(ownerState.color)}`]];\n  }\n})(({\n  ownerState,\n  theme\n}) => {\n  const backgroundColor = getColorShade(theme, ownerState.color);\n  return _extends({\n    position: 'absolute',\n    marginTop: 0,\n    height: '100%',\n    width: '100%'\n  }, ownerState.color === 'inherit' && {\n    opacity: 0.3\n  }, {\n    backgroundImage: `radial-gradient(${backgroundColor} 0%, ${backgroundColor} 16%, transparent 42%)`,\n    backgroundSize: '10px 10px',\n    backgroundPosition: '0 -23px'\n  });\n}, css(_t4 || (_t4 = _`\n    animation: ${0} 3s infinite linear;\n  `), bufferKeyframe));\nconst LinearProgressBar1 = styled('span', {\n  name: 'MuiLinearProgress',\n  slot: 'Bar1',\n  overridesResolver: (props, styles) => {\n    const {\n      ownerState\n    } = props;\n    return [styles.bar, styles[`barColor${capitalize(ownerState.color)}`], (ownerState.variant === 'indeterminate' || ownerState.variant === 'query') && styles.bar1Indeterminate, ownerState.variant === 'determinate' && styles.bar1Determinate, ownerState.variant === 'buffer' && styles.bar1Buffer];\n  }\n})(({\n  ownerState,\n  theme\n}) => _extends({\n  width: '100%',\n  position: 'absolute',\n  left: 0,\n  bottom: 0,\n  top: 0,\n  transition: 'transform 0.2s linear',\n  transformOrigin: 'left',\n  backgroundColor: ownerState.color === 'inherit' ? 'currentColor' : (theme.vars || theme).palette[ownerState.color].main\n}, ownerState.variant === 'determinate' && {\n  transition: `transform .${TRANSITION_DURATION}s linear`\n}, ownerState.variant === 'buffer' && {\n  zIndex: 1,\n  transition: `transform .${TRANSITION_DURATION}s linear`\n}), ({\n  ownerState\n}) => (ownerState.variant === 'indeterminate' || ownerState.variant === 'query') && css(_t5 || (_t5 = _`\n      width: auto;\n      animation: ${0} 2.1s cubic-bezier(0.65, 0.815, 0.735, 0.395) infinite;\n    `), indeterminate1Keyframe));\nconst LinearProgressBar2 = styled('span', {\n  name: 'MuiLinearProgress',\n  slot: 'Bar2',\n  overridesResolver: (props, styles) => {\n    const {\n      ownerState\n    } = props;\n    return [styles.bar, styles[`barColor${capitalize(ownerState.color)}`], (ownerState.variant === 'indeterminate' || ownerState.variant === 'query') && styles.bar2Indeterminate, ownerState.variant === 'buffer' && styles.bar2Buffer];\n  }\n})(({\n  ownerState,\n  theme\n}) => _extends({\n  width: '100%',\n  position: 'absolute',\n  left: 0,\n  bottom: 0,\n  top: 0,\n  transition: 'transform 0.2s linear',\n  transformOrigin: 'left'\n}, ownerState.variant !== 'buffer' && {\n  backgroundColor: ownerState.color === 'inherit' ? 'currentColor' : (theme.vars || theme).palette[ownerState.color].main\n}, ownerState.color === 'inherit' && {\n  opacity: 0.3\n}, ownerState.variant === 'buffer' && {\n  backgroundColor: getColorShade(theme, ownerState.color),\n  transition: `transform .${TRANSITION_DURATION}s linear`\n}), ({\n  ownerState\n}) => (ownerState.variant === 'indeterminate' || ownerState.variant === 'query') && css(_t6 || (_t6 = _`\n      width: auto;\n      animation: ${0} 2.1s cubic-bezier(0.165, 0.84, 0.44, 1) 1.15s infinite;\n    `), indeterminate2Keyframe));\n\n/**\n * ## ARIA\n *\n * If the progress bar is describing the loading progress of a particular region of a page,\n * you should use `aria-describedby` to point to the progress bar, and set the `aria-busy`\n * attribute to `true` on that region until it has finished loading.\n */\nconst LinearProgress = /*#__PURE__*/React.forwardRef(function LinearProgress(inProps, ref) {\n  const props = useThemeProps({\n    props: inProps,\n    name: 'MuiLinearProgress'\n  });\n  const {\n      className,\n      color = 'primary',\n      value,\n      valueBuffer,\n      variant = 'indeterminate'\n    } = props,\n    other = _objectWithoutPropertiesLoose(props, _excluded);\n  const ownerState = _extends({}, props, {\n    color,\n    variant\n  });\n  const classes = useUtilityClasses(ownerState);\n  const theme = useTheme();\n  const rootProps = {};\n  const inlineStyles = {\n    bar1: {},\n    bar2: {}\n  };\n  if (variant === 'determinate' || variant === 'buffer') {\n    if (value !== undefined) {\n      rootProps['aria-valuenow'] = Math.round(value);\n      rootProps['aria-valuemin'] = 0;\n      rootProps['aria-valuemax'] = 100;\n      let transform = value - 100;\n      if (theme.direction === 'rtl') {\n        transform = -transform;\n      }\n      inlineStyles.bar1.transform = `translateX(${transform}%)`;\n    } else if (process.env.NODE_ENV !== 'production') {\n      console.error('MUI: You need to provide a value prop ' + 'when using the determinate or buffer variant of LinearProgress .');\n    }\n  }\n  if (variant === 'buffer') {\n    if (valueBuffer !== undefined) {\n      let transform = (valueBuffer || 0) - 100;\n      if (theme.direction === 'rtl') {\n        transform = -transform;\n      }\n      inlineStyles.bar2.transform = `translateX(${transform}%)`;\n    } else if (process.env.NODE_ENV !== 'production') {\n      console.error('MUI: You need to provide a valueBuffer prop ' + 'when using the buffer variant of LinearProgress.');\n    }\n  }\n  return /*#__PURE__*/_jsxs(LinearProgressRoot, _extends({\n    className: clsx(classes.root, className),\n    ownerState: ownerState,\n    role: \"progressbar\"\n  }, rootProps, {\n    ref: ref\n  }, other, {\n    children: [variant === 'buffer' ? /*#__PURE__*/_jsx(LinearProgressDashed, {\n      className: classes.dashed,\n      ownerState: ownerState\n    }) : null, /*#__PURE__*/_jsx(LinearProgressBar1, {\n      className: classes.bar1,\n      ownerState: ownerState,\n      style: inlineStyles.bar1\n    }), variant === 'determinate' ? null : /*#__PURE__*/_jsx(LinearProgressBar2, {\n      className: classes.bar2,\n      ownerState: ownerState,\n      style: inlineStyles.bar2\n    })]\n  }));\n});\nprocess.env.NODE_ENV !== \"production\" ? LinearProgress.propTypes /* remove-proptypes */ = {\n  // ----------------------------- Warning --------------------------------\n  // | These PropTypes are generated from the TypeScript type definitions |\n  // |     To update them edit the d.ts file and run \"yarn proptypes\"     |\n  // ----------------------------------------------------------------------\n  /**\n   * Override or extend the styles applied to the component.\n   */\n  classes: PropTypes.object,\n  /**\n   * @ignore\n   */\n  className: PropTypes.string,\n  /**\n   * The color of the component.\n   * It supports both default and custom theme colors, which can be added as shown in the\n   * [palette customization guide](https://mui.com/material-ui/customization/palette/#custom-colors).\n   * @default 'primary'\n   */\n  color: PropTypes /* @typescript-to-proptypes-ignore */.oneOfType([PropTypes.oneOf(['inherit', 'primary', 'secondary']), PropTypes.string]),\n  /**\n   * The system prop that allows defining system overrides as well as additional CSS styles.\n   */\n  sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object]),\n  /**\n   * The value of the progress indicator for the determinate and buffer variants.\n   * Value between 0 and 100.\n   */\n  value: PropTypes.number,\n  /**\n   * The value for the buffer variant.\n   * Value between 0 and 100.\n   */\n  valueBuffer: PropTypes.number,\n  /**\n   * The variant to use.\n   * Use indeterminate or query when there is no progress value.\n   * @default 'indeterminate'\n   */\n  variant: PropTypes.oneOf(['buffer', 'determinate', 'indeterminate', 'query'])\n} : void 0;\nexport default LinearProgress;","import { PlusCircleIcon, SyncIcon, XCircleIcon } from \"@primer/octicons-react\";\nimport classNames from \"classnames\";\nimport React, {\n  Suspense,\n  lazy,\n  useCallback,\n  useEffect,\n  useRef,\n  useState,\n} from \"react\";\nimport { useDispatch } from \"react-redux\";\n\nimport { buildAction } from \"../../helper/eventHandlerHelper\";\nimport {\n  getDeviceMotionEventPermission,\n  labelOptions,\n  motionThresholdCondition,\n} from \"../../helper/gameHelper\";\nimport { useConnectSetting } from \"../../hooks/useConnectSettings\";\nimport type { AppDispatch } from \"../../slices\";\nimport {\n  debugToggled,\n  getMemoryStorageStatus,\n  logger,\n  setMotionThreshold,\n  setPersistentStorage,\n  setSwipeThreshold,\n  toggleDarkMode,\n} from \"../../slices/globalSlice\";\nimport { togglePhraseActiveGrp } from \"../../slices/phraseSlice\";\nimport { DebugLevel } from \"../../slices/settingHelper\";\nimport { toggleVocabularyActiveGrp } from \"../../slices/vocabularySlice\";\nimport { NotReady } from \"../Form/NotReady\";\nimport SettingsSwitch from \"../Form/SettingsSwitch\";\nimport \"../../css/Settings.css\";\nimport \"../../css/spin.css\";\nconst SettingsKanji = lazy(() => import(\"../Form/SettingsKanji\"));\nconst SettingsPhrase = lazy(() => import(\"../Form/SettingsPhrase\"));\nconst SettingsVocab = lazy(() => import(\"../Form/SettingsVocab\"));\nconst SettingsOppositeGame = lazy(() => import(\"../Form/SettingsGOpposite\"));\nconst SettingsKanaGame = lazy(() => import(\"../Form/SettingsGKana\"));\nconst SettingsKanjiGame = lazy(() => import(\"../Form/SettingsGKanji\"));\nconst SettingsParticleGame = lazy(() => import(\"../Form/SettingsGParticle\"));\nconst SettingsStats = lazy(() => import(\"../Form/SettingsStats\"));\n\nconst SettingsMeta = {\n  location: \"/settings/\",\n  label: \"Settings\",\n};\n\n// FIXME: getDerivedStateFromError\n/*\nfunction /*static getDerivedStateFromError(error: Error) {\n  const causeMsg =\n    (error.cause !== undefined && [\n      { msg: JSON.stringify(error.cause).replaceAll(\",\", \", \"), css: \"px-4\" },\n    ]) ||\n    [];\n\n  const errorMsgs = [\n    { msg: error.name + \": \" + error.message, css: \"px-2\" },\n    ...causeMsg,\n  ].map((e) => ({ ...e, lvl: DebugLevel.ERROR }));\n\n  // state\n  return {\n    errorMsgs,\n  };\n}\n*/\nfunction componentDidCatch(dispatch: AppDispatch, error: Error) {\n  const cause = error.cause as { code: string; value: unknown };\n\n  dispatch(debugToggled(DebugLevel.DEBUG));\n\n  switch (cause?.code) {\n    case \"StaleVocabActiveGrp\":\n      {\n        const stale = cause.value as string;\n        dispatch(logger(\"Error: \" + error.message, DebugLevel.ERROR));\n        dispatch(\n          logger(\n            \"Group \" + JSON.stringify(stale) + \" Removed\",\n            DebugLevel.ERROR\n          )\n        );\n        dispatch(toggleVocabularyActiveGrp(stale));\n        // FIXME: componentDidCatch setState\n        // this.setState({ errorMsgs: [] });\n      }\n\n      break;\n    case \"StalePhraseActiveGrp\":\n      {\n        const stale = cause.value as string;\n        dispatch(logger(\"Error: \" + error.message, DebugLevel.ERROR));\n        dispatch(\n          logger(\n            \"Group \" + JSON.stringify(stale) + \" Removed\",\n            DebugLevel.ERROR\n          )\n        );\n        dispatch(togglePhraseActiveGrp(stale));\n        // FIXME: componentDidCatch setState\n        // this.setState({ errorMsgs: [] });\n      }\n\n      break;\n    case \"DeviceMotionEvent\":\n      {\n        dispatch(logger(\"Error: \" + error.message, DebugLevel.ERROR));\n        dispatch(setMotionThreshold(0));\n      }\n      break;\n  }\n}\n\nfunction buildMotionListener(\n  dispatch: AppDispatch,\n  motionThreshold: number,\n  setShakeIntensity: React.Dispatch<React.SetStateAction<number | undefined>>\n) {\n  /**\n   * Handler for when device is shaken\n   */\n  return function listener(event: DeviceMotionEvent) {\n    try {\n      motionThresholdCondition(event, motionThreshold, (value) => {\n        setShakeIntensity(Number(value.toFixed(2)));\n        setTimeout(() => {\n          setShakeIntensity(undefined);\n        }, 300);\n      });\n    } catch (error) {\n      if (error instanceof Error) {\n        componentDidCatch(dispatch, error);\n      }\n    }\n  };\n}\n\nexport function collapseExpandToggler(\n  name: boolean,\n  toggleSection: (arg0: (arg1: boolean) => boolean) => void\n) {\n  const icon = name ? (\n    <XCircleIcon className=\"clickable\" size=\"medium\" aria-label=\"collapse\" />\n  ) : (\n    <PlusCircleIcon className=\"clickable\" size=\"medium\" aria-label=\"expand\" />\n  );\n\n  return <h2 onClick={() => toggleSection((t) => !t)}>{icon}</h2>;\n}\n\n/**\n * Classnames for page sections\n */\nconst pageClassName = classNames({ \"mb-5\": true });\n\nexport default function Settings() {\n  const dispatch = useDispatch<AppDispatch>();\n  const motionListener = useRef<\n    ReturnType<typeof buildMotionListener> | undefined\n  >(undefined);\n\n  const { darkMode, swipeThreshold, motionThreshold, memory, debug } =\n    useConnectSetting();\n\n  const [spin, setSpin] = useState(false);\n\n  const [sectionKanji, setSectionKanji] = useState(false);\n  const [sectionVocabulary, setSectionVocabulary] = useState(false);\n  const [sectionPhrase, setSectionPhrase] = useState(false);\n  const [sectionOpposites, setSectionOpposites] = useState(false);\n  const [sectionKana, setSectionKana] = useState(false);\n  const [sectionKanjiGame, setSectionKanjiGame] = useState(false);\n  const [sectionParticle, setSectionParticle] = useState(false);\n  const [sectionStats, setSectionStats] = useState(false);\n  const [swVersion, setSwVersion] = useState(\"\");\n  const [jsVersion, setJsVersion] = useState(\"\");\n  const [bundleVersion, setBundleVersion] = useState(\"\");\n  const [hardRefreshUnavailable, setHardRefreshUnavailable] = useState(false);\n  // const [errorMsgs, setErrorMsgs] = useState<ConsoleMessage[]>([]);\n  const [shakeIntensity, setShakeIntensity] = useState<number | undefined>(0);\n\n  useEffect(\n    () => {\n      void dispatch(getMemoryStorageStatus());\n\n      navigator.serviceWorker.addEventListener(\n        \"message\",\n        swMessageEventListener\n      );\n\n      navigator.serviceWorker.controller?.postMessage({\n        type: \"SW_VERSION\",\n      });\n\n      return () => {\n        navigator.serviceWorker.removeEventListener(\n          \"message\",\n          swMessageEventListener\n        );\n\n        if (motionListener.current) {\n          window.removeEventListener(\"devicemotion\", motionListener.current);\n        }\n      };\n    },\n    [\n      /** On mount and dismount */\n    ]\n  );\n\n  useEffect(() => {\n    if (motionThreshold > 0 && motionListener.current === undefined) {\n      motionListener.current = buildMotionListener(\n        dispatch,\n        motionThreshold,\n        setShakeIntensity\n      );\n\n      getDeviceMotionEventPermission(\n        () => {\n          if (motionListener.current)\n            window.addEventListener(\"devicemotion\", motionListener.current);\n        },\n        (error: Error) => componentDidCatch(dispatch, error)\n      );\n    } else if (motionThreshold === 0 && motionListener.current !== undefined) {\n      window.removeEventListener(\"devicemotion\", motionListener.current);\n      motionListener.current = undefined;\n    } else {\n      if (motionListener.current)\n        window.removeEventListener(\"devicemotion\", motionListener.current);\n\n      motionListener.current = buildMotionListener(\n        dispatch,\n        motionThreshold,\n        setShakeIntensity\n      );\n\n      getDeviceMotionEventPermission(\n        () => {\n          if (motionListener.current)\n            window.addEventListener(\"devicemotion\", motionListener.current);\n        },\n        (error: Error) => componentDidCatch(dispatch, error)\n      );\n    }\n  }, [dispatch, motionThreshold]);\n\n  const swMessageEventListener = useCallback(\n    (event: MessageEvent) => {\n      const { type, error } = event.data as { type: string; error: string };\n      if (type === \"DO_HARD_REFRESH\") {\n        if (error) {\n          dispatch(logger(error, DebugLevel.ERROR));\n        }\n\n        setTimeout(() => {\n          setSpin(false);\n          setHardRefreshUnavailable(true);\n        }, 2000);\n      } else if (type === \"SW_VERSION\") {\n        interface VersionInfo {\n          swVersion: string;\n          jsVersion: string;\n          bundleVersion: string;\n        }\n        const { swVersion, jsVersion, bundleVersion } =\n          event.data as VersionInfo;\n\n        setSwVersion(swVersion);\n        setJsVersion(jsVersion);\n        setBundleVersion(bundleVersion);\n      }\n    },\n    [dispatch]\n  );\n\n  // FIXME: errorMsgs component\n  // if (errorMsgs.length > 0) {\n  //   const minState = logify(this.state);\n  //   const minProps = logify(this.props);\n\n  //   const messages = [\n  //     ...errorMsgs,\n  //     { msg: \"props:\", lvl: DebugLevel.WARN, css: \"px-2\" },\n  //     { msg: minProps, lvl: DebugLevel.WARN, css: \"px-4\" },\n  //     { msg: \"state:\", lvl: DebugLevel.WARN, css: \"px-2\" },\n  //     { msg: minState, lvl: DebugLevel.WARN, css: \"px-4\" },\n  //   ];\n\n  //   return (\n  //     <div>\n  //       <div className=\"d-flex flex-column justify-content-around\">\n  //         <Console messages={messages} />\n  //       </div>\n  //     </div>\n  //   );\n  // }\n\n  return (\n    <div className=\"settings\">\n      <div className=\"d-flex flex-column justify-content-between px-3\">\n        <div className={pageClassName}>\n          <div className=\"d-flex justify-content-between\">\n            <h2>Global</h2>\n            <h2></h2>\n          </div>\n          <div>\n            <div className=\"d-flex flex-row justify-content-between\">\n              <div className=\"column-1 d-flex flex-column justify-content-end\">\n                <div\n                  className={classNames({\n                    \"w-25 d-flex flex-row justify-content-between\": true,\n                    invisible: swipeThreshold === 0,\n                  })}\n                >\n                  <div\n                    className=\"clickable px-2 pb-2\"\n                    onClick={() => {\n                      if (swipeThreshold - 1 <= 0) {\n                        dispatch(setSwipeThreshold(0));\n                      } else {\n                        dispatch(setSwipeThreshold(swipeThreshold - 1));\n                      }\n                    }}\n                  >\n                    -\n                  </div>\n                  <div className=\"px-2\">{swipeThreshold}</div>\n                  <div\n                    className=\"clickable px-2\"\n                    onClick={() =>\n                      dispatch(setSwipeThreshold(swipeThreshold + 1))\n                    }\n                  >\n                    +\n                  </div>\n                </div>\n\n                <div\n                  className={classNames({\n                    \"w-25 d-flex flex-row justify-content-between\": true,\n                    invisible: motionThreshold === 0,\n                  })}\n                >\n                  <div\n                    className=\"clickable px-2 pb-2\"\n                    onClick={() => {\n                      if (motionThreshold - 0.5 <= 0) {\n                        dispatch(setMotionThreshold(0));\n                      } else {\n                        dispatch(setMotionThreshold(motionThreshold - 0.5));\n                      }\n                    }}\n                  >\n                    -\n                  </div>\n                  <div\n                    className={classNames({\n                      \"px-2\": true,\n                      \"correct-color\":\n                        shakeIntensity &&\n                        shakeIntensity > motionThreshold &&\n                        shakeIntensity <= motionThreshold + 1,\n                      \"question-color\":\n                        shakeIntensity &&\n                        shakeIntensity > motionThreshold + 1 &&\n                        shakeIntensity <= motionThreshold + 2,\n                      \"incorrect-color\":\n                        shakeIntensity && shakeIntensity > motionThreshold + 2,\n                    })}\n                  >\n                    {shakeIntensity ?? motionThreshold}\n                  </div>\n                  <div\n                    className=\"clickable px-2\"\n                    onClick={() => {\n                      dispatch(setMotionThreshold(motionThreshold + 0.5));\n                    }}\n                  >\n                    +\n                  </div>\n                </div>\n              </div>\n              <div className=\"column-2\">\n                <div className=\"setting-block\">\n                  <SettingsSwitch\n                    active={darkMode}\n                    action={buildAction(dispatch, toggleDarkMode)}\n                    statusText={(darkMode ? \"Dark\" : \"Light\") + \" Mode\"}\n                  />\n                </div>\n                <div className=\"setting-block\">\n                  <SettingsSwitch\n                    active={swipeThreshold > 0}\n                    action={() => {\n                      swipeThreshold > 0\n                        ? dispatch(setSwipeThreshold(0))\n                        : dispatch(setSwipeThreshold(1));\n                    }}\n                    statusText={\"Touch Swipes\"}\n                  />\n                </div>\n                <div className=\"setting-block\">\n                  <SettingsSwitch\n                    active={motionThreshold > 0}\n                    action={() => {\n                      if (motionThreshold === 0) {\n                        dispatch(setMotionThreshold(6));\n                      } else {\n                        dispatch(setMotionThreshold(0));\n                      }\n                    }}\n                    statusText={\"Accelerometer\"}\n                  />\n                </div>\n              </div>\n            </div>\n          </div>\n        </div>\n        <div className={pageClassName}>\n          <div className=\"d-flex justify-content-between\">\n            <h2>Phrases</h2>\n            {collapseExpandToggler(sectionPhrase, setSectionPhrase)}\n          </div>\n          {sectionPhrase && (\n            <Suspense\n              fallback={\n                <NotReady addlStyle=\"phrases-settings\" text=\"Loading...\" />\n              }\n            >\n              <SettingsPhrase />\n            </Suspense>\n          )}\n        </div>\n        <div className={pageClassName}>\n          <div className=\"d-flex justify-content-between\">\n            <h2>Vocabulary</h2>\n            {collapseExpandToggler(sectionVocabulary, setSectionVocabulary)}\n          </div>\n          {sectionVocabulary && (\n            <Suspense\n              fallback={\n                <NotReady addlStyle=\"vocabulary-settings\" text=\"Loading...\" />\n              }\n            >\n              <SettingsVocab />\n            </Suspense>\n          )}\n        </div>\n        <div className={pageClassName}>\n          <div className=\"d-flex justify-content-between\">\n            <h2>Kanji</h2>\n            {collapseExpandToggler(sectionKanji, setSectionKanji)}\n          </div>\n          {sectionKanji && (\n            <Suspense\n              fallback={\n                <NotReady addlStyle=\"kanji-settings\" text=\"Loading...\" />\n              }\n            >\n              <SettingsKanji />\n            </Suspense>\n          )}\n        </div>\n        <div className={pageClassName}>\n          <div className=\"d-flex justify-content-between\">\n            <h2>Opposites Game</h2>\n            {collapseExpandToggler(sectionOpposites, setSectionOpposites)}\n          </div>\n          {sectionOpposites && (\n            <Suspense\n              fallback={\n                <NotReady addlStyle=\"opposites-settings\" text=\"Loading...\" />\n              }\n            >\n              <SettingsOppositeGame />\n            </Suspense>\n          )}\n        </div>\n        <div className={pageClassName}>\n          <div className=\"d-flex justify-content-between\">\n            <h2>Kana Game</h2>\n            {collapseExpandToggler(sectionKana, setSectionKana)}\n          </div>\n          {sectionKana && (\n            <Suspense\n              fallback={\n                <NotReady addlStyle=\"kana-settings\" text=\"Loading...\" />\n              }\n            >\n              <SettingsKanaGame />\n            </Suspense>\n          )}\n        </div>\n\n        <div className={pageClassName}>\n          <div className=\"d-flex justify-content-between\">\n            <h2>Kanji Game</h2>\n            {collapseExpandToggler(sectionKanjiGame, setSectionKanjiGame)}\n          </div>\n          {sectionKanjiGame && (\n            <Suspense\n              fallback={\n                <NotReady addlStyle=\"kanji-game-settings\" text=\"Loading...\" />\n              }\n            >\n              <SettingsKanjiGame />\n            </Suspense>\n          )}\n        </div>\n\n        <div className={pageClassName}>\n          <div className=\"d-flex justify-content-between\">\n            <h2>Particles Game</h2>\n            {collapseExpandToggler(sectionParticle, setSectionParticle)}\n          </div>\n          {sectionParticle && (\n            <Suspense\n              fallback={\n                <NotReady addlStyle=\"particle-settings\" text=\"Loading...\" />\n              }\n            >\n              <SettingsParticleGame />\n            </Suspense>\n          )}\n        </div>\n\n        <div className={pageClassName}>\n          <div className=\"d-flex justify-content-between\">\n            <h2>Study Stats</h2>\n            {collapseExpandToggler(sectionStats, setSectionStats)}\n          </div>\n          {sectionStats && (\n            <Suspense\n              fallback={\n                <NotReady addlStyle=\"stats-settings\" text=\"Loading...\" />\n              }\n            >\n              <SettingsStats />\n            </Suspense>\n          )}\n        </div>\n\n        <div className={pageClassName}>\n          <div className=\"d-flex justify-content-between\">\n            <h2>Application</h2>\n          </div>\n          <div className=\"d-flex flex-column flex-sm-row justify-content-between\">\n            <div className=\"column-1\">\n              <div className=\"setting-block mb-2 mt-2\">\n                <div\n                  className=\"d-flex flex-row w-50 w-sm-100 justify-content-between clickable\"\n                  onClick={() => {\n                    setSwVersion(\"\");\n                    setJsVersion(\"\");\n                    setBundleVersion(\"\");\n                    setTimeout(() => {\n                      navigator.serviceWorker.controller?.postMessage({\n                        type: \"SW_VERSION\",\n                      });\n                    }, 1000);\n                  }}\n                >\n                  <div className=\"pe-2\">\n                    <div>{\"swVersion:\"}</div>\n                    <div>{\"jsVersion:\"}</div>\n                    <div>{\"bundleVersion:\"}</div>\n                  </div>\n                  <div>\n                    <div>{swVersion}</div>\n                    <div>{jsVersion}</div>\n                    <div>{bundleVersion}</div>\n                  </div>\n                </div>\n              </div>\n            </div>\n            <div className=\"column-2\">\n              <div className=\"setting-block mb-2\">\n                <SettingsSwitch\n                  active={debug > DebugLevel.OFF}\n                  action={buildAction(dispatch, debugToggled)}\n                  color=\"default\"\n                  statusText={labelOptions(debug, [\n                    \"Debug\",\n                    \"Debug Error\",\n                    \"Debug Warn\",\n                    \"Debug\",\n                  ])}\n                />\n              </div>\n              <div\n                className={classNames({\n                  \"d-flex justify-content-end mb-2\": true,\n                  \"disabled-color\": hardRefreshUnavailable,\n                })}\n              >\n                <p id=\"hard-refresh\" className=\"text-right\">\n                  Hard Refresh\n                </p>\n                <div\n                  className={classNames({\n                    \"spin-a-bit\": spin,\n                  })}\n                  style={{ height: \"24px\" }}\n                  aria-labelledby=\"hard-refresh\"\n                  onClick={() => {\n                    setSpin(true);\n                    setHardRefreshUnavailable(false);\n\n                    setTimeout(() => {\n                      if (spin) {\n                        setSpin(false);\n                        setHardRefreshUnavailable(true);\n                      }\n                    }, 3000);\n\n                    navigator.serviceWorker.controller?.postMessage({\n                      type: \"DO_HARD_REFRESH\",\n                    });\n                  }}\n                >\n                  <SyncIcon\n                    className=\"clickable\"\n                    size={24}\n                    aria-label=\"Hard Refresh\"\n                  />\n                </div>\n              </div>\n\n              <div className=\"setting-block mb-2\">\n                <SettingsSwitch\n                  active={memory.persistent}\n                  action={buildAction(dispatch, setPersistentStorage)}\n                  disabled={memory.persistent}\n                  color=\"default\"\n                  statusText={\n                    memory.persistent\n                      ? `Persistent ${~~(memory.usage / 1024 / 1024)}\n                        /\n                        ${~~(memory.quota / 1024 / 1024)}\n                        MB`\n                      : \"Persistent off\"\n                  }\n                />\n              </div>\n            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n}\n\nexport { SettingsMeta };\n","import { PayloadAction, createAsyncThunk, createSlice } from \"@reduxjs/toolkit\";\nimport merge from \"lodash/fp/merge\";\n\nimport { logger } from \"./globalSlice\";\nimport {\n  DebugLevel,\n  TermFilterBy,\n  TermSortBy,\n  deleteMetadata,\n  grpParse,\n  toggleAFilter,\n  updateSpaceRepTerm,\n} from \"./settingHelper\";\nimport { firebaseConfig } from \"../../environment.production\";\nimport { localStoreAttrUpdate } from \"../helper/localStorageHelper\";\nimport {\n  SR_MIN_REV_ITEMS,\n  removeAction,\n  updateAction,\n} from \"../helper/recallHelper\";\nimport { buildGroupObject, getPropsFromTags } from \"../helper/reducerHelper\";\nimport { MEMORIZED_THRLD } from \"../helper/sortHelper\";\nimport type {\n  GroupListMap,\n  MetaDataObj,\n  RawPhrase,\n  SourcePhrase,\n  ValuesOf,\n} from \"../typings/raw\";\n\nimport type { RootState } from \".\";\n\nexport interface PhraseInitSlice {\n  value: RawPhrase[];\n  version: string;\n  grpObj: GroupListMap;\n\n  setting: {\n    ordered: ValuesOf<typeof TermSortBy>;\n    englishSideUp: boolean;\n    romaji: boolean;\n    reinforce: boolean;\n    repTID: number;\n    repetition: Record<string, MetaDataObj | undefined>;\n    spaRepMaxReviewItem: number;\n    frequency: { uid?: string; count: number };\n    activeGroup: string[];\n    filter: ValuesOf<typeof TermFilterBy>;\n    difficultyThreshold: number;\n    includeNew: boolean;\n    includeReviewed: boolean;\n  };\n}\n\nexport const phraseInitState: PhraseInitSlice = {\n  value: [],\n  version: \"\",\n  grpObj: {},\n\n  setting: {\n    ordered: 0,\n    englishSideUp: false,\n    romaji: false,\n    reinforce: false,\n    repTID: -1,\n    repetition: {},\n    spaRepMaxReviewItem: SR_MIN_REV_ITEMS,\n    frequency: { uid: undefined, count: 0 },\n    activeGroup: [],\n    filter: 0,\n    difficultyThreshold: MEMORIZED_THRLD,\n    includeNew: true,\n    includeReviewed: true,\n  },\n};\n\n/**\n * For inverse tagged phrases\n * Checks that an initial uid has atleast one pair\n */\nfunction inversePairCheck<T extends SourcePhrase>(\n  initial: string,\n  object: Record<string, T>\n) {\n  let errors;\n\n  let { inverse } = getPropsFromTags(object[initial].tag);\n  let inversePair = inverse;\n\n  while (inversePair && inversePair !== initial) {\n    const { inverse } = getPropsFromTags(object[inversePair]?.tag);\n\n    if (inverse) {\n      inversePair = inverse;\n    } else {\n      // match failed\n      inversePair = undefined;\n      errors = [\n        ...(errors ?? []),\n        `Missing inverse pair for ${object[initial].japanese}`,\n      ];\n    }\n  }\n\n  return errors;\n}\n\n/**\n * Determine if a phrase is polite.\n *\n * **When** they contain multiple periods or commas; polite phrases are left **unedited**.\n *\n * *Otherwise* the period is *removed*.\n *\n * @param o\n * @returns\n */\nexport function isPolitePhrase<T extends { japanese: string }>(o: T) {\n  let polite: { japanese?: string; polite: boolean } = { polite: false };\n  if (o.japanese.endsWith(\"。\")) {\n    const [furigana, phrase] = o.japanese.split(\"\\n\");\n\n    let withoutDot;\n    if (\n      furigana.indexOf(\"。\") !== furigana.lastIndexOf(\"。\") ||\n      furigana.includes(\"、\")\n    ) {\n      // multiple 。or 、\n      // japanese is not defined. withoutDot is not used.\n      polite = { polite: true };\n    } else {\n      if (phrase?.endsWith(\"。\") && furigana.endsWith(\"。\")) {\n        withoutDot = `${furigana.slice(0, -1)}\\n${phrase.slice(0, -1)}`;\n      } else {\n        withoutDot = o.japanese.slice(0, -1);\n      }\n\n      polite = { japanese: withoutDot, polite: true };\n    }\n  }\n\n  return polite;\n}\n\nexport function buildPhraseArray<T extends SourcePhrase>(\n  object: Record<string, T>\n): { values: RawPhrase[]; errors?: string[] } {\n  let errors: undefined | string[];\n  const values = Object.keys(object).map((k) => {\n    let { tags, particles, inverse } = getPropsFromTags(object[k].tag);\n\n    errors = inversePairCheck(k, object);\n\n    const o = object[k];\n    const polite = isPolitePhrase(o);\n\n    return {\n      ...object[k],\n      uid: k,\n\n      // Not used after parsing\n      tag: undefined,\n\n      // Derived from tag\n      tags,\n      particles,\n      inverse,\n      ...polite,\n    };\n  });\n\n  return { values, errors };\n}\n\n/**\n * Fetch phrases\n */\nexport const getPhrase = createAsyncThunk(\n  \"phrase/getPhrase\",\n  async (arg, thunkAPI) => {\n    const state = thunkAPI.getState() as RootState;\n    // TODO: rename state.phrases -> state.phrase\n    const version = state.version.phrases ?? \"0\";\n\n    // if (version === \"0\") {\n    //   console.error(\"fetching phrase: 0\");\n    // }\n    const jsonValue = (await fetch(\n      firebaseConfig.databaseURL + \"/lambda/phrases.json\",\n      {\n        headers: { \"Data-Version\": version },\n      }\n    ).then((res) => res.json())) as Record<string, SourcePhrase>;\n\n    const groups = buildGroupObject(jsonValue);\n    const { values, errors } = buildPhraseArray(jsonValue);\n    if (errors) {\n      errors.forEach((e) => {\n        thunkAPI.dispatch(logger(e, DebugLevel.WARN));\n      });\n    }\n\n    return { version, values, groups };\n  }\n);\n\nexport const phraseFromLocalStorage = createAsyncThunk(\n  \"phrase/phraseFromLocalStorage\",\n  (arg: typeof phraseInitState.setting) => {\n    const initValues = arg;\n\n    return initValues;\n  }\n);\n\nexport const deleteMetaPhrase = createAsyncThunk(\n  \"phrase/deleteMetaPhrase\",\n  (uidList: string[], thunkAPI) => {\n    const state = (thunkAPI.getState() as RootState).phrases;\n    const spaceRep = state.setting.repetition;\n\n    return deleteMetadata(uidList, spaceRep);\n  }\n);\n\nexport const updateSpaceRepPhrase = createAsyncThunk(\n  \"phrase/updateSpaceRepPhrase\",\n  (arg: { uid: string; shouldIncrement: boolean }, thunkAPI) => {\n    const { uid, shouldIncrement } = arg;\n    const state = (thunkAPI.getState() as RootState).phrases;\n\n    const spaceRep = state.setting.repetition;\n\n    return updateSpaceRepTerm(uid, spaceRep, {\n      count: shouldIncrement,\n      date: true,\n    });\n  }\n);\n\nexport const removeFromSpaceRepetition = createAsyncThunk(\n  \"phrase/removeFromSpaceRepetition\",\n  (arg: { uid: string }, thunkAPI) => {\n    const { uid } = arg;\n    const state = (thunkAPI.getState() as RootState).phrases;\n\n    const spaceRep = state.setting.repetition;\n    return removeAction(uid, spaceRep);\n  }\n);\n\nexport const setSpaceRepetitionMetadata = createAsyncThunk(\n  \"phrase/setSpaceRepetitionMetadata\",\n  (arg: { uid: string }, thunkAPI) => {\n    const { uid } = arg;\n    const state = (thunkAPI.getState() as RootState).phrases;\n\n    const spaceRep = state.setting.repetition;\n    return updateAction(uid, spaceRep);\n  }\n);\n\nconst phraseSlice = createSlice({\n  name: \"phrase\",\n  initialState: phraseInitState,\n  reducers: {\n    /**\n     * Toggle between group, frequency, and tags filtering\n     */\n    togglePhrasesFilter(\n      state,\n      action: { payload?: ValuesOf<typeof TermFilterBy> }\n    ) {\n      const override = action.payload;\n\n      const allowed = [TermFilterBy.FREQUENCY, TermFilterBy.GROUP];\n\n      const { filter, reinforce } = state.setting;\n\n      const newFilter = toggleAFilter(\n        filter + 1,\n        allowed,\n        override\n      ) as ValuesOf<typeof TermFilterBy>;\n\n      state.setting.filter = localStoreAttrUpdate(\n        new Date(),\n        { phrases: state.setting },\n        \"/phrases/\",\n        \"filter\",\n        newFilter\n      );\n\n      if (newFilter !== TermFilterBy.GROUP && reinforce) {\n        state.setting.reinforce = false;\n      }\n    },\n\n    togglePhraseActiveGrp(state, action: { payload: string }) {\n      const grpName = action.payload;\n\n      const { activeGroup } = state.setting;\n\n      const groups = Array.isArray(grpName) ? grpName : [grpName];\n      const newValue: string[] = grpParse(groups, activeGroup);\n\n      state.setting.activeGroup = localStoreAttrUpdate(\n        new Date(),\n        { phrases: state.setting },\n        \"/phrases/\",\n        \"activeGroup\",\n        newValue\n      );\n    },\n    togglePhrasesReinforcement(\n      state,\n      action: { payload: boolean | undefined }\n    ) {\n      const newValue = action.payload;\n\n      state.setting.reinforce = localStoreAttrUpdate(\n        new Date(),\n        { phrases: state.setting },\n        \"/phrases/\",\n        \"reinforce\",\n        newValue\n      );\n    },\n\n    setMemorizedThreshold(state, action: { payload: number }) {\n      const threshold = action.payload;\n\n      state.setting.difficultyThreshold = localStoreAttrUpdate(\n        new Date(),\n        { phrases: state.setting },\n        \"/phrases/\",\n        \"difficultyThreshold\",\n        threshold\n      );\n    },\n\n    setPhraseDifficulty: {\n      reducer: (\n        state: PhraseInitSlice,\n        action: { payload: { uid: string; value: number | null } }\n      ) => {\n        const { uid, value } = action.payload;\n\n        const { record: newValue } = updateSpaceRepTerm(\n          uid,\n          state.setting.repetition,\n          { count: false, date: false },\n          {\n            set: { difficultyP: value },\n          }\n        );\n\n        state.setting.repTID = Date.now();\n        state.setting.repetition = localStoreAttrUpdate(\n          new Date(),\n          { phrases: state.setting },\n          \"/phrases/\",\n          \"repetition\",\n          newValue\n        );\n      },\n      prepare: (uid: string, value: number | null) => ({\n        payload: { uid, value },\n      }),\n    },\n    /**\n     * Space Repetition maximum item review\n     * per session\n     */\n    setSpaRepMaxItemReview(state, action: PayloadAction<number>) {\n      const value = Math.max(SR_MIN_REV_ITEMS, action.payload);\n\n      state.setting.spaRepMaxReviewItem = localStoreAttrUpdate(\n        new Date(),\n        { phrases: state.setting },\n        \"/phrases/\",\n        \"spaRepMaxReviewItem\",\n        value\n      );\n    },\n    setPhraseAccuracy: {\n      reducer: (\n        state: PhraseInitSlice,\n        action: { payload: { uid: string; value: number | null } }\n      ) => {\n        const { uid, value } = action.payload;\n\n        const { record: newValue } = updateSpaceRepTerm(\n          uid,\n          state.setting.repetition,\n          { count: false, date: false },\n          {\n            set: { accuracyP: value },\n          }\n        );\n\n        state.setting.repTID = Date.now();\n        state.setting.repetition = localStoreAttrUpdate(\n          new Date(),\n          { phrases: state.setting },\n          \"/phrases/\",\n          \"repetition\",\n          newValue\n        );\n      },\n      prepare: (uid: string, value: number | null) => ({\n        payload: { uid, value },\n      }),\n    },\n\n    addFrequencyPhrase(state, action: PayloadAction<string>) {\n      const uid = action.payload;\n      const { record: newValue } = updateSpaceRepTerm(\n        uid,\n        state.setting.repetition,\n        { count: false, date: false },\n        {\n          set: { rein: true },\n        }\n      );\n\n      state.setting.repTID = Date.now();\n      state.setting.repetition = localStoreAttrUpdate(\n        new Date(),\n        { phrases: state.setting },\n        \"/phrases/\",\n        \"repetition\",\n        newValue\n      );\n\n      let frequency = { uid, count: state.setting.frequency.count + 1 };\n      state.setting.frequency = localStoreAttrUpdate(\n        new Date(),\n        { phrases: state.setting },\n        \"/phrases/\",\n        \"frequency\",\n        frequency\n      );\n    },\n\n    removeFrequencyPhrase(state, action: { payload: string }) {\n      const uid = action.payload;\n\n      const spaceRep = state.setting.repetition;\n      if (spaceRep[uid]?.rein === true) {\n        // null to delete\n        const { record: newValue } = updateSpaceRepTerm(\n          uid,\n          spaceRep,\n          { count: false, date: false },\n          {\n            set: { rein: null },\n          }\n        );\n\n        state.setting.repTID = Date.now();\n        state.setting.repetition = localStoreAttrUpdate(\n          new Date(),\n          { phrases: state.setting },\n          \"/phrases/\",\n          \"repetition\",\n          newValue\n        );\n\n        let frequency = { uid, count: state.setting.frequency.count - 1 };\n        state.setting.frequency = localStoreAttrUpdate(\n          new Date(),\n          { phrases: state.setting },\n          \"/phrases/\",\n          \"frequency\",\n          frequency\n        );\n      }\n    },\n\n    flipPhrasesPracticeSide(state) {\n      state.setting.englishSideUp = localStoreAttrUpdate(\n        new Date(),\n        { phrases: state.setting },\n        \"/phrases/\",\n        \"englishSideUp\"\n      );\n    },\n\n    togglePhrasesRomaji(state) {\n      state.setting.romaji = localStoreAttrUpdate(\n        new Date(),\n        { phrases: state.setting },\n        \"/phrases/\",\n        \"romaji\"\n      );\n    },\n\n    togglePhrasesOrdering(\n      state,\n      action: PayloadAction<ValuesOf<typeof TermSortBy>>\n    ) {\n      const allowed = [\n        TermSortBy.RANDOM,\n        TermSortBy.VIEW_DATE,\n        TermSortBy.RECALL,\n      ];\n      const override = action.payload;\n\n      const { ordered } = state.setting;\n\n      let newOrdered = toggleAFilter(\n        ordered + 1,\n        allowed,\n        override\n      ) as ValuesOf<typeof TermSortBy>;\n\n      state.setting.ordered = localStoreAttrUpdate(\n        new Date(),\n        { phrases: state.setting },\n        \"/phrases/\",\n        \"ordered\",\n        newOrdered\n      );\n    },\n    toggleIncludeNew(state) {\n      state.setting.includeNew = localStoreAttrUpdate(\n        new Date(),\n        { phrases: state.setting },\n        \"/phrases/\",\n        \"includeNew\"\n      );\n    },\n    toggleIncludeReviewed(state) {\n      state.setting.includeReviewed = localStoreAttrUpdate(\n        new Date(),\n        { phrases: state.setting },\n        \"/phrases/\",\n        \"includeReviewed\"\n      );\n    },\n  },\n\n  extraReducers: (builder) => {\n    builder.addCase(getPhrase.fulfilled, (state, action) => {\n      const { version, values, groups } = action.payload;\n      state.grpObj = groups;\n      state.value = values;\n      state.version = version;\n    });\n\n    builder.addCase(phraseFromLocalStorage.fulfilled, (state, action) => {\n      const localStorageValue = action.payload;\n      const mergedSettings = merge(phraseInitState.setting, localStorageValue);\n\n      const phraseReinforceList = Object.keys(mergedSettings.repetition).filter(\n        (k) => mergedSettings.repetition[k]?.rein === true\n      );\n      mergedSettings.frequency = {\n        uid: undefined,\n        count: phraseReinforceList.length,\n      };\n\n      return {\n        ...state,\n        setting: { ...mergedSettings, repTID: Date.now() },\n      };\n    });\n    builder.addCase(updateSpaceRepPhrase.fulfilled, (state, action) => {\n      const { record: newValue } = action.payload;\n\n      state.setting.repTID = Date.now();\n      state.setting.repetition = localStoreAttrUpdate(\n        new Date(),\n        { phrases: state.setting },\n        \"/phrases/\",\n        \"repetition\",\n        newValue\n      );\n    });\n    builder.addCase(setSpaceRepetitionMetadata.fulfilled, (state, action) => {\n      const { newValue } = action.payload;\n\n      state.setting.repTID = Date.now();\n      state.setting.repetition = localStoreAttrUpdate(\n        new Date(),\n        { phrases: state.setting },\n        \"/phrases/\",\n        \"repetition\",\n        newValue\n      );\n    });\n    builder.addCase(removeFromSpaceRepetition.fulfilled, (state, action) => {\n      const newValue = action.payload;\n\n      if (newValue) {\n        state.setting.repTID = Date.now();\n        state.setting.repetition = localStoreAttrUpdate(\n          new Date(),\n          { phrases: state.setting },\n          \"/phrases/\",\n          \"repetition\",\n          newValue\n        );\n      }\n    });\n\n    builder.addCase(deleteMetaPhrase.fulfilled, (state, action) => {\n      const { record: newValue } = action.payload;\n\n      state.setting.repTID = Date.now();\n      state.setting.repetition = localStoreAttrUpdate(\n        new Date(),\n        { phrases: state.setting },\n        \"/phrases/\",\n        \"repetition\",\n        newValue\n      );\n    });\n  },\n});\n\nexport const {\n  flipPhrasesPracticeSide,\n  togglePhrasesRomaji,\n  togglePhrasesFilter,\n  togglePhraseActiveGrp,\n  togglePhrasesReinforcement,\n  toggleIncludeNew,\n  toggleIncludeReviewed,\n  addFrequencyPhrase,\n  setPhraseDifficulty,\n  setPhraseAccuracy,\n  setMemorizedThreshold,\n  setSpaRepMaxItemReview,\n\n  removeFrequencyPhrase,\n  togglePhrasesOrdering,\n} = phraseSlice.actions;\nexport default phraseSlice.reducer;\n"],"names":[],"mappings":";;;;;;;;;;AAgCA;;;;;;;;AASA;;;;;;;;;;;;AAaA;;;;AAyBA;;;AAGA;AACA;AACA;;;AAGA;AACA;;;AAGA;;;;;;;;;AASA;;AAEA;AACA;AACA;;;AAGA;;;;;AAKA;;AAEA;;;;AAIA;;;;;;;;;;;;;;;AC9EA;;;;;;;;;;;;;;;AAgBA;;;;;;;;;;;;;;;AAgBA;AA2FA;AACA;;AA+BA;AACA;;AAgCA;AACA;;AC+ZA;AACA;AClgBA"}