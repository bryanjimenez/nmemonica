{"version":3,"file":"main.a51605b8.js","sources":["./prod-dep-replacement.cjs??ruleSet[1].rules[2].use[0]!./src/slices/phraseSlice.ts"],"sourcesContent":["import { PayloadAction, createAsyncThunk, createSlice } from \"@reduxjs/toolkit\";\nimport merge from \"lodash/fp/merge\";\n\nimport { logger } from \"./globalSlice\";\nimport {\n  DebugLevel,\n  TermFilterBy,\n  TermSortBy,\n  deleteMetadata,\n  grpParse,\n  toggleAFilter,\n  updateSpaceRepTerm,\n} from \"./settingHelper\";\nimport { firebaseConfig } from \"../../environment.production\";\nimport { localStoreAttrUpdate } from \"../helper/localStorageHelper\";\nimport {\n  SR_MIN_REV_ITEMS,\n  removeAction,\n  updateAction,\n} from \"../helper/recallHelper\";\nimport { buildGroupObject, getPropsFromTags } from \"../helper/reducerHelper\";\nimport { MEMORIZED_THRLD } from \"../helper/sortHelper\";\nimport type {\n  GroupListMap,\n  MetaDataObj,\n  RawPhrase,\n  SourcePhrase,\n  ValuesOf,\n} from \"../typings/raw\";\n\nimport type { RootState } from \".\";\n\nexport interface PhraseInitSlice {\n  value: RawPhrase[];\n  version: string;\n  grpObj: GroupListMap;\n\n  setting: {\n    ordered: ValuesOf<typeof TermSortBy>;\n    englishSideUp: boolean;\n    romaji: boolean;\n    reinforce: boolean;\n    repTID: number;\n    repetition: Record<string, MetaDataObj | undefined>;\n    spaRepMaxReviewItem: number;\n    frequency: { uid?: string; count: number };\n    activeGroup: string[];\n    filter: ValuesOf<typeof TermFilterBy>;\n    difficultyThreshold: number;\n    includeNew: boolean;\n    includeReviewed: boolean;\n  };\n}\n\nexport const phraseInitState: PhraseInitSlice = {\n  value: [],\n  version: \"\",\n  grpObj: {},\n\n  setting: {\n    ordered: 0,\n    englishSideUp: false,\n    romaji: false,\n    reinforce: false,\n    repTID: -1,\n    repetition: {},\n    spaRepMaxReviewItem: SR_MIN_REV_ITEMS,\n    frequency: { uid: undefined, count: 0 },\n    activeGroup: [],\n    filter: 0,\n    difficultyThreshold: MEMORIZED_THRLD,\n    includeNew: true,\n    includeReviewed: true,\n  },\n};\n\n/**\n * For inverse tagged phrases\n * Checks that an initial uid has atleast one pair\n */\nfunction inversePairCheck<T extends SourcePhrase>(\n  initial: string,\n  object: Record<string, T>\n) {\n  let errors;\n\n  let { inverse } = getPropsFromTags(object[initial].tag);\n  let inversePair = inverse;\n\n  while (inversePair && inversePair !== initial) {\n    const { inverse } = getPropsFromTags(object[inversePair]?.tag);\n\n    if (inverse) {\n      inversePair = inverse;\n    } else {\n      // match failed\n      inversePair = undefined;\n      errors = [\n        ...(errors ?? []),\n        `Missing inverse pair for ${object[initial].japanese}`,\n      ];\n    }\n  }\n\n  return errors;\n}\n\n/**\n * Determine if a phrase is polite.\n *\n * **When** they contain multiple periods or commas; polite phrases are left **unedited**.\n *\n * *Otherwise* the period is *removed*.\n *\n * @param o\n * @returns\n */\nexport function isPolitePhrase<T extends { japanese: string }>(o: T) {\n  let polite: { japanese?: string; polite: boolean } = { polite: false };\n  if (o.japanese.endsWith(\"。\")) {\n    const [furigana, phrase] = o.japanese.split(\"\\n\");\n\n    let withoutDot;\n    if (\n      furigana.indexOf(\"。\") !== furigana.lastIndexOf(\"。\") ||\n      furigana.includes(\"、\")\n    ) {\n      // multiple 。or 、\n      // japanese is not defined. withoutDot is not used.\n      polite = { polite: true };\n    } else {\n      if (phrase?.endsWith(\"。\") && furigana.endsWith(\"。\")) {\n        withoutDot = `${furigana.slice(0, -1)}\\n${phrase.slice(0, -1)}`;\n      } else {\n        withoutDot = o.japanese.slice(0, -1);\n      }\n\n      polite = { japanese: withoutDot, polite: true };\n    }\n  }\n\n  return polite;\n}\n\nexport function buildPhraseArray<T extends SourcePhrase>(\n  object: Record<string, T>\n): { values: RawPhrase[]; errors?: string[] } {\n  let errors: undefined | string[];\n  const values = Object.keys(object).map((k) => {\n    let { tags, particles, inverse } = getPropsFromTags(object[k].tag);\n\n    errors = inversePairCheck(k, object);\n\n    const o = object[k];\n    const polite = isPolitePhrase(o);\n\n    return {\n      ...object[k],\n      uid: k,\n\n      // Not used after parsing\n      tag: undefined,\n\n      // Derived from tag\n      tags,\n      particles,\n      inverse,\n      ...polite,\n    };\n  });\n\n  return { values, errors };\n}\n\n/**\n * Fetch phrases\n */\nexport const getPhrase = createAsyncThunk(\n  \"phrase/getPhrase\",\n  async (arg, thunkAPI) => {\n    const state = thunkAPI.getState() as RootState;\n    // TODO: rename state.phrases -> state.phrase\n    const version = state.version.phrases ?? \"0\";\n\n    // if (version === \"0\") {\n    //   console.error(\"fetching phrase: 0\");\n    // }\n    const jsonValue = (await fetch(\n      firebaseConfig.databaseURL + \"/lambda/phrases.json\",\n      {\n        headers: { \"Data-Version\": version },\n      }\n    ).then((res) => res.json())) as Record<string, SourcePhrase>;\n\n    const groups = buildGroupObject(jsonValue);\n    const { values, errors } = buildPhraseArray(jsonValue);\n    if (errors) {\n      errors.forEach((e) => {\n        thunkAPI.dispatch(logger(e, DebugLevel.WARN));\n      });\n    }\n\n    return { version, values, groups };\n  }\n);\n\nexport const phraseFromLocalStorage = createAsyncThunk(\n  \"phrase/phraseFromLocalStorage\",\n  (arg: typeof phraseInitState.setting) => {\n    const initValues = arg;\n\n    return initValues;\n  }\n);\n\nexport const deleteMetaPhrase = createAsyncThunk(\n  \"phrase/deleteMetaPhrase\",\n  (uidList: string[], thunkAPI) => {\n    const state = (thunkAPI.getState() as RootState).phrases;\n    const spaceRep = state.setting.repetition;\n\n    return deleteMetadata(uidList, spaceRep);\n  }\n);\n\nexport const updateSpaceRepPhrase = createAsyncThunk(\n  \"phrase/updateSpaceRepPhrase\",\n  (arg: { uid: string; shouldIncrement: boolean }, thunkAPI) => {\n    const { uid, shouldIncrement } = arg;\n    const state = (thunkAPI.getState() as RootState).phrases;\n\n    const spaceRep = state.setting.repetition;\n\n    return updateSpaceRepTerm(uid, spaceRep, {\n      count: shouldIncrement,\n      date: true,\n    });\n  }\n);\n\nexport const removeFromSpaceRepetition = createAsyncThunk(\n  \"phrase/removeFromSpaceRepetition\",\n  (arg: { uid: string }, thunkAPI) => {\n    const { uid } = arg;\n    const state = (thunkAPI.getState() as RootState).phrases;\n\n    const spaceRep = state.setting.repetition;\n    return removeAction(uid, spaceRep);\n  }\n);\n\nexport const setSpaceRepetitionMetadata = createAsyncThunk(\n  \"phrase/setSpaceRepetitionMetadata\",\n  (arg: { uid: string }, thunkAPI) => {\n    const { uid } = arg;\n    const state = (thunkAPI.getState() as RootState).phrases;\n\n    const spaceRep = state.setting.repetition;\n    return updateAction(uid, spaceRep);\n  }\n);\n\nconst phraseSlice = createSlice({\n  name: \"phrase\",\n  initialState: phraseInitState,\n  reducers: {\n    /**\n     * Toggle between group, frequency, and tags filtering\n     */\n    togglePhrasesFilter(\n      state,\n      action: { payload?: ValuesOf<typeof TermFilterBy> }\n    ) {\n      const override = action.payload;\n\n      const allowed = [TermFilterBy.FREQUENCY, TermFilterBy.GROUP];\n\n      const { filter, reinforce } = state.setting;\n\n      const newFilter = toggleAFilter(\n        filter + 1,\n        allowed,\n        override\n      ) as ValuesOf<typeof TermFilterBy>;\n\n      state.setting.filter = localStoreAttrUpdate(\n        new Date(),\n        { phrases: state.setting },\n        \"/phrases/\",\n        \"filter\",\n        newFilter\n      );\n\n      if (newFilter !== TermFilterBy.GROUP && reinforce) {\n        state.setting.reinforce = false;\n      }\n    },\n\n    togglePhraseActiveGrp(state, action: { payload: string }) {\n      const grpName = action.payload;\n\n      const { activeGroup } = state.setting;\n\n      const groups = Array.isArray(grpName) ? grpName : [grpName];\n      const newValue: string[] = grpParse(groups, activeGroup);\n\n      state.setting.activeGroup = localStoreAttrUpdate(\n        new Date(),\n        { phrases: state.setting },\n        \"/phrases/\",\n        \"activeGroup\",\n        newValue\n      );\n    },\n    togglePhrasesReinforcement(\n      state,\n      action: { payload: boolean | undefined }\n    ) {\n      const newValue = action.payload;\n\n      state.setting.reinforce = localStoreAttrUpdate(\n        new Date(),\n        { phrases: state.setting },\n        \"/phrases/\",\n        \"reinforce\",\n        newValue\n      );\n    },\n\n    setMemorizedThreshold(state, action: { payload: number }) {\n      const threshold = action.payload;\n\n      state.setting.difficultyThreshold = localStoreAttrUpdate(\n        new Date(),\n        { phrases: state.setting },\n        \"/phrases/\",\n        \"difficultyThreshold\",\n        threshold\n      );\n    },\n\n    setPhraseDifficulty: {\n      reducer: (\n        state: PhraseInitSlice,\n        action: { payload: { uid: string; value: number | null } }\n      ) => {\n        const { uid, value } = action.payload;\n\n        const { record: newValue } = updateSpaceRepTerm(\n          uid,\n          state.setting.repetition,\n          { count: false, date: false },\n          {\n            set: { difficultyP: value },\n          }\n        );\n\n        state.setting.repTID = Date.now();\n        state.setting.repetition = localStoreAttrUpdate(\n          new Date(),\n          { phrases: state.setting },\n          \"/phrases/\",\n          \"repetition\",\n          newValue\n        );\n      },\n      prepare: (uid: string, value: number | null) => ({\n        payload: { uid, value },\n      }),\n    },\n    /**\n     * Space Repetition maximum item review\n     * per session\n     */\n    setSpaRepMaxItemReview(state, action: PayloadAction<number>) {\n      const value = Math.max(SR_MIN_REV_ITEMS, action.payload);\n\n      state.setting.spaRepMaxReviewItem = localStoreAttrUpdate(\n        new Date(),\n        { phrases: state.setting },\n        \"/phrases/\",\n        \"spaRepMaxReviewItem\",\n        value\n      );\n    },\n    setPhraseAccuracy: {\n      reducer: (\n        state: PhraseInitSlice,\n        action: { payload: { uid: string; value: number | null } }\n      ) => {\n        const { uid, value } = action.payload;\n\n        const { record: newValue } = updateSpaceRepTerm(\n          uid,\n          state.setting.repetition,\n          { count: false, date: false },\n          {\n            set: { accuracyP: value },\n          }\n        );\n\n        state.setting.repTID = Date.now();\n        state.setting.repetition = localStoreAttrUpdate(\n          new Date(),\n          { phrases: state.setting },\n          \"/phrases/\",\n          \"repetition\",\n          newValue\n        );\n      },\n      prepare: (uid: string, value: number | null) => ({\n        payload: { uid, value },\n      }),\n    },\n\n    addFrequencyPhrase(state, action: PayloadAction<string>) {\n      const uid = action.payload;\n      const { record: newValue } = updateSpaceRepTerm(\n        uid,\n        state.setting.repetition,\n        { count: false, date: false },\n        {\n          set: { rein: true },\n        }\n      );\n\n      state.setting.repTID = Date.now();\n      state.setting.repetition = localStoreAttrUpdate(\n        new Date(),\n        { phrases: state.setting },\n        \"/phrases/\",\n        \"repetition\",\n        newValue\n      );\n\n      let frequency = { uid, count: state.setting.frequency.count + 1 };\n      state.setting.frequency = localStoreAttrUpdate(\n        new Date(),\n        { phrases: state.setting },\n        \"/phrases/\",\n        \"frequency\",\n        frequency\n      );\n    },\n\n    removeFrequencyPhrase(state, action: { payload: string }) {\n      const uid = action.payload;\n\n      const spaceRep = state.setting.repetition;\n      if (spaceRep[uid]?.rein === true) {\n        // null to delete\n        const { record: newValue } = updateSpaceRepTerm(\n          uid,\n          spaceRep,\n          { count: false, date: false },\n          {\n            set: { rein: null },\n          }\n        );\n\n        state.setting.repTID = Date.now();\n        state.setting.repetition = localStoreAttrUpdate(\n          new Date(),\n          { phrases: state.setting },\n          \"/phrases/\",\n          \"repetition\",\n          newValue\n        );\n\n        let frequency = { uid, count: state.setting.frequency.count - 1 };\n        state.setting.frequency = localStoreAttrUpdate(\n          new Date(),\n          { phrases: state.setting },\n          \"/phrases/\",\n          \"frequency\",\n          frequency\n        );\n      }\n    },\n\n    flipPhrasesPracticeSide(state) {\n      state.setting.englishSideUp = localStoreAttrUpdate(\n        new Date(),\n        { phrases: state.setting },\n        \"/phrases/\",\n        \"englishSideUp\"\n      );\n    },\n\n    togglePhrasesRomaji(state) {\n      state.setting.romaji = localStoreAttrUpdate(\n        new Date(),\n        { phrases: state.setting },\n        \"/phrases/\",\n        \"romaji\"\n      );\n    },\n\n    togglePhrasesOrdering(\n      state,\n      action: PayloadAction<ValuesOf<typeof TermSortBy>>\n    ) {\n      const allowed = [\n        TermSortBy.RANDOM,\n        TermSortBy.VIEW_DATE,\n        TermSortBy.RECALL,\n      ];\n      const override = action.payload;\n\n      const { ordered } = state.setting;\n\n      let newOrdered = toggleAFilter(\n        ordered + 1,\n        allowed,\n        override\n      ) as ValuesOf<typeof TermSortBy>;\n\n      state.setting.ordered = localStoreAttrUpdate(\n        new Date(),\n        { phrases: state.setting },\n        \"/phrases/\",\n        \"ordered\",\n        newOrdered\n      );\n    },\n    toggleIncludeNew(state) {\n      state.setting.includeNew = localStoreAttrUpdate(\n        new Date(),\n        { phrases: state.setting },\n        \"/phrases/\",\n        \"includeNew\"\n      );\n    },\n    toggleIncludeReviewed(state) {\n      state.setting.includeReviewed = localStoreAttrUpdate(\n        new Date(),\n        { phrases: state.setting },\n        \"/phrases/\",\n        \"includeReviewed\"\n      );\n    },\n  },\n\n  extraReducers: (builder) => {\n    builder.addCase(getPhrase.fulfilled, (state, action) => {\n      const { version, values, groups } = action.payload;\n      state.grpObj = groups;\n      state.value = values;\n      state.version = version;\n    });\n\n    builder.addCase(phraseFromLocalStorage.fulfilled, (state, action) => {\n      const localStorageValue = action.payload;\n      const mergedSettings = merge(phraseInitState.setting, localStorageValue);\n\n      const phraseReinforceList = Object.keys(mergedSettings.repetition).filter(\n        (k) => mergedSettings.repetition[k]?.rein === true\n      );\n      mergedSettings.frequency = {\n        uid: undefined,\n        count: phraseReinforceList.length,\n      };\n\n      return {\n        ...state,\n        setting: { ...mergedSettings, repTID: Date.now() },\n      };\n    });\n    builder.addCase(updateSpaceRepPhrase.fulfilled, (state, action) => {\n      const { record: newValue } = action.payload;\n\n      state.setting.repTID = Date.now();\n      state.setting.repetition = localStoreAttrUpdate(\n        new Date(),\n        { phrases: state.setting },\n        \"/phrases/\",\n        \"repetition\",\n        newValue\n      );\n    });\n    builder.addCase(setSpaceRepetitionMetadata.fulfilled, (state, action) => {\n      const { newValue } = action.payload;\n\n      state.setting.repTID = Date.now();\n      state.setting.repetition = localStoreAttrUpdate(\n        new Date(),\n        { phrases: state.setting },\n        \"/phrases/\",\n        \"repetition\",\n        newValue\n      );\n    });\n    builder.addCase(removeFromSpaceRepetition.fulfilled, (state, action) => {\n      const newValue = action.payload;\n\n      if (newValue) {\n        state.setting.repTID = Date.now();\n        state.setting.repetition = localStoreAttrUpdate(\n          new Date(),\n          { phrases: state.setting },\n          \"/phrases/\",\n          \"repetition\",\n          newValue\n        );\n      }\n    });\n\n    builder.addCase(deleteMetaPhrase.fulfilled, (state, action) => {\n      const { record: newValue } = action.payload;\n\n      state.setting.repTID = Date.now();\n      state.setting.repetition = localStoreAttrUpdate(\n        new Date(),\n        { phrases: state.setting },\n        \"/phrases/\",\n        \"repetition\",\n        newValue\n      );\n    });\n  },\n});\n\nexport const {\n  flipPhrasesPracticeSide,\n  togglePhrasesRomaji,\n  togglePhrasesFilter,\n  togglePhraseActiveGrp,\n  togglePhrasesReinforcement,\n  toggleIncludeNew,\n  toggleIncludeReviewed,\n  addFrequencyPhrase,\n  setPhraseDifficulty,\n  setPhraseAccuracy,\n  setMemorizedThreshold,\n  setSpaRepMaxItemReview,\n\n  removeFrequencyPhrase,\n  togglePhrasesOrdering,\n} = phraseSlice.actions;\nexport default phraseSlice.reducer;\n"],"names":[],"mappings":";AAmIA"}